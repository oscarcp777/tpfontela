/*
 *  BTreeNode.cpp
 *
 *  Created on: 02/04/2010
 *      Author: santiago
 */

#include "BTreeNode.h"


template <class keyType>
BTreeNode<keyType>::BTreeNode(int maxKeys, int unique):SimpleIndex<keyType>(maxKeys+1, unique) { init(); }

template <class keyType>
BTreeNode<keyType>::~BTreeNode() { }

template <class keyType>
int BTreeNode<keyType>::init(){
	this->nextNode = -1;
	this->recAddr = -1;
	this->maxBKeys = this->maxKeys-1;
	this->minKeys = this->maxBKeys / 2;
	return 1;
}

template <class keyType>
int BTreeNode<keyType>::insert(const keyType key, int recAddr){
	int result;
	result = SimpleIndex<keyType>::insert(key, recAddr);
	if (!result) return 0; //fallo insercion
	if (this->numKeys >= this->maxKeys) return -1; //overflow nodo
	return -1;
}

template <class keyType>
int BTreeNode<keyType>::remove(const keyType key, int dir){
	int result;
	result = SimpleIndex<keyType>::remove(key, recAddr);
	if (!result) return 0; //fallo remover
	if (this->numKeys < this->minKeys) return -1; //underflow nodo
}

template <class keyType>
char* BTreeNode<keyType>::largestKey(){ 	   //retorna el valor de la clave mayor
	if (this->numKeys > 0) return this->keys[this->numKeys-1];
	else return this->keys[0];

}

template <class keyType>
int BTreeNode<keyType>::split(BTreeNode* newNode){ 		//mover al nuevo nodo

	if (this->numKeys < this->maxKeys) return 0; // chequea si hay suficiente num de claves
	int midpt = (this->numKeys + 1)/2; //encuentra la primer clave a ser movida al nuevo nodo
	int numNewKeys = this->numKeys - midpt;
	//chequea que el numero de claves para el nuevo nodo este ok
	if (numNewKeys > newNode->maxBKeys || numNewKeys < newNode->minKeys)
		return 0;

	//mueve las claves y direcciones desde aca al nuevo nodo
	for(int i = midpt; i < this->numKeys; i++){
		newNode->keys[i-midpt] = this->keys[i];
		newNode->direcciones[i-midpt] = this->direcciones[i];
	}
	//setea el numero de claves en los 2 nodos
	newNode->numKeys = numNewKeys;
	this->numKeys = midpt;
	return 1;
}

template <class keyType>
int BTreeNode<keyType>::merge(BTreeNode* fromNode){		//mueve desde el nodo

	//chequea si hay demasiadas claves
	if (this->numKeys + fromNode->numKeys > this->maxKeys-1) return 0;
	//mueve claves y direcciones desde fromNode a este nodo
	for(int i = 0; i < fromNode->numKeys; i++){
		this->keys[this->numKeys+i] = fromNode->keys[i];
		this->recAddrs[this->numKeys+i] = fromNode->recAddrs[i];
	}
	//ajustar numero de claves
	this->numKeys += fromNode->numKeys;

	return 1;
}

template <class keyType>
int BTreeNode<keyType>::updateKey(keyType oldKey, keyType newKey, int recAddr){

	int recaddr = this->search(oldKey,recAddr);
	if (recaddr < 0) return 0; 		// clave y direccion no encontradas
	this->remove(oldKey,recAddr);
	this->insert(newKey,recaddr);
	return 1;
}

template <class keyType>
int BTreeNode<keyType>::pack(IOBuffer& buffer) const{
	int result;
	buffer.clear();
	result = buffer.pack(&this->numKeys);
	for (int i = 0; i<this->numKeys; i++){
		result = result && buffer.pack(&this->keys[i]);
		result = result && buffer.pack(&this->recAddrs[i]);
	}
	return result;
}

template <class keyType>
int BTreeNode<keyType>::unpack(IOBuffer& buffer){
	int result;
	result = buffer.unPack(&this->numKeys);
	for (int i = 0; i<this->numKeys; i++){
		result = result && buffer.unPack(&this->keys[i]);
		result = result && buffer.unPack(&this->recAddrs[i]);
	}
	return result;
}

template <class keyType>
void BTreeNode<keyType>::print() const{
	SimpleIndex<keyType>::print();
}

//Inicializa buffer para el nodo
template <class keyType>
int BTreeNode<keyType>::initBuffer(FixedFieldBuffer & buffer, int maxKeys, int keySize){
	buffer.addField(sizeof(int));
	for (int i = 0; i < maxKeys; i++){
		buffer.addField(keySize);
		buffer.addField(sizeof(int));
	}
	return 1;

}
